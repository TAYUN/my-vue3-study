---
inclusion: always
---

# 编码规范和最佳实践

## TypeScript 编码规范

### 类型定义
- 优先使用接口(interface)定义对象类型
- 使用泛型提高代码复用性
- 避免使用 `any` 类型，使用 `unknown` 替代
- 为函数参数和返回值明确指定类型

```typescript
// ✅ 推荐
interface ReactiveEffect {
  (): any
  deps: Dep[]
  active: boolean
}

// ❌ 避免
function createEffect(fn: any): any {
  // ...
}
```

### 命名约定
- 使用 camelCase 命名变量和函数
- 使用 PascalCase 命名类型和接口
- 常量使用 UPPER_SNAKE_CASE
- 私有属性使用下划线前缀

```typescript
// 变量和函数
const activeEffect: ReactiveEffect | undefined = undefined
function createReactiveObject() {}

// 类型和接口
interface Target extends Record<string | symbol, any> {}
type Dep = Set<ReactiveEffect>

// 常量
const ITERATE_KEY = Symbol('iterate')
```

## 文件组织规范

### 目录结构
```
packages/reactivity/src/
├── index.ts           # 导出入口
├── reactive.ts        # reactive相关实现
├── effect.ts          # effect系统实现
├── baseHandlers.ts    # Proxy处理器
├── collectionHandlers.ts  # 集合类型处理器
└── constants.ts       # 常量定义
```

### 导入导出规范
- 使用命名导出，避免默认导出
- 按功能模块组织导入
- 使用相对路径导入本地模块

```typescript
// ✅ 推荐的导入顺序
// 1. Node.js 内置模块
// 2. 第三方库
// 3. 本地模块
import { isObject } from '@vue/shared'
import { track, trigger } from './effect'
import { mutableHandlers } from './baseHandlers'
```

## 注释规范

### 函数注释
使用JSDoc格式为重要函数添加注释：

```typescript
/**
 * 创建响应式对象
 * @param target - 要代理的目标对象
 * @returns 响应式代理对象
 */
export function reactive<T extends object>(target: T): T {
  return createReactiveObject(target, mutableHandlers)
}
```

### 代码注释
- 解释复杂的业务逻辑
- 说明设计决策的原因
- 标注TODO和FIXME

```typescript
// 使用WeakMap避免内存泄漏，当target被回收时自动清理依赖
const targetMap = new WeakMap<any, KeyToDepMap>()

// TODO: 优化数组响应式性能
// FIXME: 处理循环引用问题
```

## 错误处理

### 参数验证
```typescript
export function reactive(target: unknown) {
  // 参数类型检查
  if (!isObject(target)) {
    console.warn(`reactive() 只能用于对象类型，收到: ${typeof target}`)
    return target
  }
  
  return createReactiveObject(target, mutableHandlers)
}
```

### 开发环境警告
```typescript
if (__DEV__) {
  console.warn('检测到潜在的性能问题')
}
```

## 性能优化原则

### 避免不必要的响应式
```typescript
// ✅ 对于不需要响应式的数据使用markRaw
const config = markRaw({ apiUrl: 'https://api.example.com' })

// ✅ 使用shallowReactive减少深度代理开销
const state = shallowReactive({ list: [] })
```

### 合理使用缓存
```typescript
// 缓存已创建的响应式对象
const reactiveMap = new WeakMap()

function createReactiveObject(target: object, handlers: ProxyHandler<any>) {
  const existingProxy = reactiveMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  
  const proxy = new Proxy(target, handlers)
  reactiveMap.set(target, proxy)
  return proxy
}
```

## 测试规范

### 测试文件命名
- 测试文件使用 `.spec.ts` 后缀
- 测试文件与源文件保持相同的目录结构

### 测试用例组织
```typescript
describe('reactive', () => {
  describe('基础功能', () => {
    test('应该返回响应式对象', () => {
      // 测试实现
    })
  })
  
  describe('边界情况', () => {
    test('应该处理null和undefined', () => {
      // 测试实现
    })
  })
})
```

## Git 提交规范

### 提交信息格式
```
<type>(<scope>): <subject>

<body>

<footer>
```

### 类型说明
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式调整
- `refactor`: 重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

### 示例
```
feat(reactivity): 实现基础reactive函数

- 添加createReactiveObject函数
- 实现基础的Proxy代理逻辑
- 添加类型定义和导出

Closes #123
```