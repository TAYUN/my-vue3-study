---
inclusion: always
---

# 响应式系统实现指南

## 核心概念理解

### 响应式系统的三大支柱
1. **响应式对象 (Reactive Object)**: 通过Proxy代理的对象，能够拦截属性访问和修改
2. **副作用函数 (Effect Function)**: 依赖响应式数据的函数，数据变化时自动重新执行
3. **依赖收集系统 (Dependency Collection)**: 建立数据与副作用函数之间的关联关系

### 数据结构设计
```typescript
// 依赖收集的核心数据结构
type Dep = Set<ReactiveEffect>
type KeyToDepMap = Map<any, Dep>
const targetMap = new WeakMap<any, KeyToDepMap>()

// 数据结构关系：
// targetMap: WeakMap {
//   target1: Map {
//     'key1' => Set { effect1, effect2 },
//     'key2' => Set { effect3 }
//   },
//   target2: Map {
//     'key1' => Set { effect4 }
//   }
// }
```

## 实现步骤指导

### 第一步：实现基础的reactive函数
```typescript
// packages/reactivity/src/reactive.ts
export function reactive<T extends object>(target: T): T {
  // 1. 参数验证
  if (!isObject(target)) {
    return target
  }
  
  // 2. 避免重复代理
  if (target[ReactiveFlags.IS_REACTIVE]) {
    return target
  }
  
  // 3. 创建代理对象
  return createReactiveObject(target, mutableHandlers)
}
```

### 第二步：实现Proxy处理器
```typescript
// packages/reactivity/src/baseHandlers.ts
export const mutableHandlers: ProxyHandler<object> = {
  get(target: object, key: string | symbol, receiver: object) {
    // 1. 处理特殊key (如ReactiveFlags)
    if (key === ReactiveFlags.IS_REACTIVE) {
      return true
    }
    
    // 2. 获取原始值
    const res = Reflect.get(target, key, receiver)
    
    // 3. 依赖收集
    track(target, TrackOpTypes.GET, key)
    
    // 4. 深度响应式处理
    if (isObject(res)) {
      return reactive(res)
    }
    
    return res
  },
  
  set(target: object, key: string | symbol, value: unknown, receiver: object) {
    // 1. 获取旧值
    const oldValue = (target as any)[key]
    
    // 2. 设置新值
    const result = Reflect.set(target, key, value, receiver)
    
    // 3. 触发更新 (只有值真正改变时才触发)
    if (hasChanged(value, oldValue)) {
      trigger(target, TriggerOpTypes.SET, key, value, oldValue)
    }
    
    return result
  }
}
```

### 第三步：实现effect系统
```typescript
// packages/reactivity/src/effect.ts
let activeEffect: ReactiveEffect | undefined

export function effect(fn: () => any) {
  const _effect = new ReactiveEffect(fn)
  _effect.run()
  return _effect
}

class ReactiveEffect {
  active = true
  deps: Dep[] = []
  
  constructor(public fn: () => any) {}
  
  run() {
    if (!this.active) {
      return this.fn()
    }
    
    try {
      activeEffect = this
      return this.fn()
    } finally {
      activeEffect = undefined
    }
  }
}
```

### 第四步：实现依赖收集
```typescript
export function track(target: object, type: TrackOpTypes, key: unknown) {
  // 1. 检查是否有活跃的effect
  if (!activeEffect) {
    return
  }
  
  // 2. 获取或创建target对应的depsMap
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  
  // 3. 获取或创建key对应的dep
  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, (dep = new Set()))
  }
  
  // 4. 建立双向关联
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect)
    activeEffect.deps.push(dep)
  }
}
```

### 第五步：实现触发更新
```typescript
export function trigger(
  target: object,
  type: TriggerOpTypes,
  key?: unknown,
  newValue?: unknown,
  oldValue?: unknown
) {
  // 1. 获取target对应的depsMap
  const depsMap = targetMap.get(target)
  if (!depsMap) {
    return
  }
  
  // 2. 收集需要执行的effects
  const effects = new Set<ReactiveEffect>()
  
  const add = (effectsToAdd: Dep | undefined) => {
    if (effectsToAdd) {
      effectsToAdd.forEach(effect => effects.add(effect))
    }
  }
  
  // 3. 根据操作类型收集effects
  if (key !== void 0) {
    add(depsMap.get(key))
  }
  
  // 4. 执行所有effects
  effects.forEach(effect => {
    if (effect !== activeEffect) {
      effect.run()
    }
  })
}
```

## 关键实现细节

### 避免重复代理
```typescript
// 使用ReactiveFlags标记已代理的对象
export const enum ReactiveFlags {
  IS_REACTIVE = '__v_isReactive'
}

// 在get陷阱中处理标记
if (key === ReactiveFlags.IS_REACTIVE) {
  return true
}
```

### 深度响应式
```typescript
// 在get陷阱中递归创建响应式对象
const res = Reflect.get(target, key, receiver)
if (isObject(res)) {
  return reactive(res) // 懒代理，只有访问时才创建
}
```

### 数组特殊处理
```typescript
// 数组的特殊方法需要特殊处理
const arrayInstrumentations: Record<string, Function> = {}

;['push', 'pop', 'shift', 'unshift', 'splice'].forEach(key => {
  arrayInstrumentations[key] = function(this: unknown[], ...args: unknown[]) {
    // 暂停依赖收集，避免无限循环
    pauseTracking()
    const res = (Array.prototype as any)[key].apply(this, args)
    resetTracking()
    return res
  }
})
```

### 性能优化策略

#### 1. 使用WeakMap避免内存泄漏
```typescript
// WeakMap的key是弱引用，对象被回收时自动清理
const targetMap = new WeakMap<any, KeyToDepMap>()
```

#### 2. 缓存代理对象
```typescript
const reactiveMap = new WeakMap<Target, any>()

function createReactiveObject(target: Target, handlers: ProxyHandler<any>) {
  const existingProxy = reactiveMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  
  const proxy = new Proxy(target, handlers)
  reactiveMap.set(target, proxy)
  return proxy
}
```

#### 3. 避免不必要的触发
```typescript
// 只有值真正改变时才触发更新
if (hasChanged(value, oldValue)) {
  trigger(target, TriggerOpTypes.SET, key, value, oldValue)
}

// hasChanged的实现
export const hasChanged = (value: any, oldValue: any): boolean =>
  !Object.is(value, oldValue)
```

## 调试技巧

### 1. 添加调试日志
```typescript
function track(target: object, type: TrackOpTypes, key: unknown) {
  if (__DEV__) {
    console.log(`[TRACK] ${target.constructor.name}.${String(key)}`)
  }
  // ... 实现逻辑
}

function trigger(target: object, type: TriggerOpTypes, key?: unknown) {
  if (__DEV__) {
    console.log(`[TRIGGER] ${target.constructor.name}.${String(key)}`)
  }
  // ... 实现逻辑
}
```

### 2. 可视化依赖关系
```typescript
// 开发工具函数
export function getTargetMap() {
  return targetMap
}

export function debugDeps(target: object) {
  const depsMap = targetMap.get(target)
  if (depsMap) {
    console.table(
      Array.from(depsMap.entries()).map(([key, dep]) => ({
        key: String(key),
        effectCount: dep.size
      }))
    )
  }
}
```

### 3. 断点调试要点
- 在get/set陷阱中设置断点，观察访问模式
- 在track/trigger函数中设置断点，理解依赖收集流程
- 检查activeEffect的变化，理解effect嵌套

## 常见问题解决

### Q: 如何避免effect无限循环？
```typescript
// 在trigger中检查当前effect
effects.forEach(effect => {
  if (effect !== activeEffect) { // 关键检查
    effect.run()
  }
})
```

### Q: 如何处理effect嵌套？
```typescript
// 使用effect栈管理嵌套
const effectStack: ReactiveEffect[] = []

class ReactiveEffect {
  run() {
    try {
      effectStack.push(this)
      activeEffect = this
      return this.fn()
    } finally {
      effectStack.pop()
      activeEffect = effectStack[effectStack.length - 1]
    }
  }
}
```

### Q: 如何优化数组性能？
```typescript
// 对于数组的length属性特殊处理
if (isArray(target) && key === 'length') {
  // 触发所有索引大于等于新length的依赖
  for (let i = Number(newValue); i < oldLength; i++) {
    add(depsMap.get(i + ''))
  }
}
```