---
inclusion: always
---

# 学习方法和调试技巧

## 学习方法论

### 渐进式学习策略
1. **理论先行**: 先理解概念，再动手实现
2. **测试驱动**: 先写测试用例，明确预期行为
3. **小步迭代**: 每次只实现一个小功能，确保可运行
4. **对比验证**: 与Vue3官方实现对比，理解差异

### 学习路径建议
```
第1天: Proxy基础 → 简单get/set拦截
第2天: reactive函数 → 基础对象代理
第3天: effect系统 → 副作用函数执行
第4天: 依赖收集 → track函数实现
第5天: 触发更新 → trigger函数实现
第6天: 嵌套对象 → 深度响应式
第7天: 数组支持 → 数组方法处理
```

### 每日学习检查清单
- [ ] 理解今日核心概念
- [ ] 完成代码实现
- [ ] 编写测试用例验证
- [ ] 记录学习笔记
- [ ] 解决遇到的问题
- [ ] 规划明日学习内容

## 调试技巧详解

### 1. 日志调试法

#### 基础日志模板
```typescript
// 在关键函数中添加日志
function reactive<T extends object>(target: T): T {
  console.log(`[REACTIVE] 创建响应式对象:`, target)
  return createReactiveObject(target, mutableHandlers)
}

function track(target: object, type: TrackOpTypes, key: unknown) {
  console.log(`[TRACK] ${target.constructor.name}.${String(key)}`)
  console.log(`[TRACK] 当前activeEffect:`, activeEffect?.fn.toString())
}

function trigger(target: object, type: TriggerOpTypes, key?: unknown) {
  console.log(`[TRIGGER] ${target.constructor.name}.${String(key)}`)
  console.log(`[TRIGGER] 触发${effects.size}个effect`)
}
```

#### 高级日志工具
```typescript
// 创建调试工具类
class ReactivityDebugger {
  private static logs: Array<{
    type: 'track' | 'trigger' | 'effect'
    timestamp: number
    target: string
    key: string
    details: any
  }> = []
  
  static log(type: 'track' | 'trigger' | 'effect', target: any, key: any, details?: any) {
    this.logs.push({
      type,
      timestamp: Date.now(),
      target: target.constructor.name,
      key: String(key),
      details
    })
  }
  
  static getLogs() {
    return this.logs
  }
  
  static clearLogs() {
    this.logs = []
  }
  
  static printSummary() {
    console.table(this.logs)
  }
}
```

### 2. 断点调试策略

#### 关键断点位置
```typescript
// 1. 在Proxy的get陷阱中设置断点
get(target: object, key: string | symbol, receiver: object) {
  debugger // 观察属性访问时机
  const res = Reflect.get(target, key, receiver)
  track(target, TrackOpTypes.GET, key)
  return res
}

// 2. 在effect执行时设置断点
run() {
  debugger // 观察effect执行上下文
  try {
    activeEffect = this
    return this.fn()
  } finally {
    activeEffect = undefined
  }
}

// 3. 在依赖收集时设置断点
export function track(target: object, type: TrackOpTypes, key: unknown) {
  if (!activeEffect) return
  debugger // 观察依赖建立过程
  // ... 依赖收集逻辑
}
```

#### 调试检查要点
- **activeEffect状态**: 确认当前是否有活跃的effect
- **targetMap结构**: 检查依赖关系是否正确建立
- **effect执行顺序**: 观察嵌套effect的执行流程
- **数据变化时机**: 确认trigger触发的时机和频率

### 3. 可视化调试工具

#### 依赖关系可视化
```typescript
// 创建依赖关系图
export function visualizeDependencies() {
  const graph: Record<string, any> = {}
  
  targetMap.forEach((depsMap, target) => {
    const targetName = target.constructor.name + '_' + Math.random().toString(36).substr(2, 9)
    graph[targetName] = {}
    
    depsMap.forEach((dep, key) => {
      graph[targetName][String(key)] = {
        effectCount: dep.size,
        effects: Array.from(dep).map(effect => effect.fn.toString().slice(0, 50))
      }
    })
  })
  
  console.log('依赖关系图:', JSON.stringify(graph, null, 2))
  return graph
}
```

#### 性能监控工具
```typescript
// 性能监控类
class PerformanceMonitor {
  private static trackCount = 0
  private static triggerCount = 0
  private static startTime = Date.now()
  
  static recordTrack() {
    this.trackCount++
  }
  
  static recordTrigger() {
    this.triggerCount++
  }
  
  static getStats() {
    const duration = Date.now() - this.startTime
    return {
      duration,
      trackCount: this.trackCount,
      triggerCount: this.triggerCount,
      trackRate: this.trackCount / duration * 1000,
      triggerRate: this.triggerCount / duration * 1000
    }
  }
  
  static reset() {
    this.trackCount = 0
    this.triggerCount = 0
    this.startTime = Date.now()
  }
}
```

### 4. 测试驱动调试

#### 单元测试模板
```typescript
// 测试响应式基础功能
describe('reactive基础功能', () => {
  test('应该创建响应式对象', () => {
    const original = { foo: 1 }
    const observed = reactive(original)
    
    expect(observed).not.toBe(original)
    expect(observed.foo).toBe(1)
  })
  
  test('应该触发effect重新执行', () => {
    const data = reactive({ count: 0 })
    let dummy
    
    effect(() => {
      dummy = data.count
    })
    
    expect(dummy).toBe(0)
    data.count = 7
    expect(dummy).toBe(7)
  })
})
```

#### 集成测试示例
```typescript
// 测试复杂场景
describe('复杂响应式场景', () => {
  test('嵌套对象响应式', () => {
    const data = reactive({
      nested: { count: 0 }
    })
    
    let dummy
    effect(() => {
      dummy = data.nested.count
    })
    
    expect(dummy).toBe(0)
    data.nested.count = 8
    expect(dummy).toBe(8)
  })
  
  test('数组响应式', () => {
    const arr = reactive([1, 2, 3])
    let sum
    
    effect(() => {
      sum = arr.reduce((a, b) => a + b, 0)
    })
    
    expect(sum).toBe(6)
    arr.push(4)
    expect(sum).toBe(10)
  })
})
```

## 常见问题诊断

### 问题1: effect没有重新执行
**症状**: 数据变化了，但effect没有重新执行

**诊断步骤**:
```typescript
// 1. 检查是否正确收集了依赖
console.log('targetMap:', targetMap)

// 2. 检查trigger是否被调用
function trigger(target, type, key) {
  console.log('trigger被调用:', { target, type, key })
  // ... 原有逻辑
}

// 3. 检查effect是否在依赖集合中
function debugEffect(target, key) {
  const depsMap = targetMap.get(target)
  const dep = depsMap?.get(key)
  console.log(`${key}的依赖:`, dep)
}
```

**常见原因**:
- activeEffect为undefined时访问了属性
- 使用了非响应式对象
- effect在执行过程中被清理

### 问题2: 无限循环更新
**症状**: 页面卡死，控制台显示大量日志

**诊断步骤**:
```typescript
// 添加循环检测
let triggerDepth = 0
const MAX_TRIGGER_DEPTH = 100

function trigger(target, type, key) {
  triggerDepth++
  if (triggerDepth > MAX_TRIGGER_DEPTH) {
    console.error('检测到无限循环更新!')
    console.trace()
    return
  }
  
  // ... 原有逻辑
  
  triggerDepth--
}
```

**常见原因**:
- effect中修改了自己依赖的数据
- 没有正确处理activeEffect检查
- 数组操作导致的循环触发

### 问题3: 内存泄漏
**症状**: 内存使用持续增长

**诊断步骤**:
```typescript
// 监控targetMap大小
setInterval(() => {
  console.log('targetMap大小:', targetMap.size)
  // 如果持续增长可能有内存泄漏
}, 5000)

// 检查effect清理
class ReactiveEffect {
  stop() {
    if (this.active) {
      cleanupEffect(this)
      this.active = false
    }
  }
}

function cleanupEffect(effect) {
  effect.deps.forEach(dep => {
    dep.delete(effect)
  })
  effect.deps.length = 0
}
```

## 学习进度跟踪

### 知识点掌握检查表
```markdown
## 基础概念 (第1-2天)
- [ ] 理解Proxy和Reflect的作用
- [ ] 掌握响应式对象的创建流程
- [ ] 了解WeakMap的使用场景

## 核心机制 (第3-5天)
- [ ] 理解effect系统的工作原理
- [ ] 掌握依赖收集的实现方式
- [ ] 理解触发更新的时机和方式

## 高级特性 (第6-7天)
- [ ] 实现嵌套对象的响应式
- [ ] 处理数组的特殊情况
- [ ] 优化性能和内存使用
```

### 实践能力验证
```typescript
// 能力验证测试
const selfTest = {
  // 测试1: 能否独立实现基础reactive
  test1() {
    // 不看文档实现一个简单的reactive函数
  },
  
  // 测试2: 能否解释依赖收集原理
  test2() {
    // 画出依赖收集的数据结构图
  },
  
  // 测试3: 能否调试复杂问题
  test3() {
    // 给定一个bug场景，能否快速定位问题
  }
}
```

## 学习资源推荐

### 官方资源
- [Vue3响应式API文档](https://vuejs.org/api/reactivity-core.html)
- [Vue3源码仓库](https://github.com/vuejs/core)
- [Vue3 RFC文档](https://github.com/vuejs/rfcs)

### 学习工具
- **浏览器开发者工具**: 断点调试和性能分析
- **Vue DevTools**: 响应式数据观察
- **TypeScript Playground**: 类型系统练习
- **Vitest**: 单元测试框架

### 进阶阅读
- 《Vue.js设计与实现》- 霍春阳
- 《深入理解Vue.js实战》
- Vue3源码解析系列文章

## 学习成果展示

### 项目里程碑
1. **基础实现**: 完成reactive和effect的基本功能
2. **功能完善**: 支持嵌套对象和数组响应式
3. **性能优化**: 实现缓存和内存管理
4. **实战应用**: 构建一个简单的响应式应用

### 知识输出建议
- 写技术博客分享学习心得
- 制作思维导图总结知识点
- 录制视频讲解实现原理
- 参与开源项目贡献代码