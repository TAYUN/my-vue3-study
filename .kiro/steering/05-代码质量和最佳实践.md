---
inclusion: always
---

# 代码质量和最佳实践

## 代码质量标准

### 可读性原则
- **函数职责单一**: 每个函数只做一件事情
- **命名清晰明确**: 变量和函数名能够自解释
- **注释恰到好处**: 解释为什么这样做，而不是做了什么
- **代码结构清晰**: 逻辑层次分明，易于理解

```typescript
// ✅ 好的示例
/**
 * 创建响应式对象的代理
 * 使用WeakMap缓存避免重复创建代理对象
 */
function createReactiveObject<T extends Target>(
  target: T,
  handlers: ProxyHandler<any>
): T {
  // 检查缓存，避免重复代理
  const existingProxy = proxyMap.get(target)
  if (existingProxy) {
    return existingProxy
  }
  
  // 创建新的代理对象
  const proxy = new Proxy(target, handlers)
  proxyMap.set(target, proxy)
  return proxy
}

// ❌ 避免的示例
function create(t: any, h: any): any {
  let p = map.get(t)
  if (p) return p
  p = new Proxy(t, h)
  map.set(t, p)
  return p
}
```

### 类型安全
- **严格的类型定义**: 避免使用any，优先使用具体类型
- **泛型的合理使用**: 提高代码复用性和类型安全
- **接口定义完整**: 为复杂对象定义清晰的接口

```typescript
// 类型定义示例
interface ReactiveEffect<T = any> {
  (): T
  _isEffect: true
  active: boolean
  raw: () => T
  deps: Array<Dep>
  options: ReactiveEffectOptions
  allowRecurse: boolean
}

type Dep = Set<ReactiveEffect>
type KeyToDepMap = Map<any, Dep>
type TargetMap = WeakMap<any, KeyToDepMap>

// 泛型使用示例
export function reactive<T extends object>(target: T): UnwrapNestedRefs<T> {
  if (isReadonly(target)) {
    return target
  }
  return createReactiveObject(
    target,
    false,
    mutableHandlers,
    mutableCollectionHandlers,
    reactiveMap
  )
}
```

### 错误处理
- **参数验证**: 在函数入口进行参数检查
- **边界情况处理**: 考虑各种异常情况
- **友好的错误信息**: 提供有用的调试信息

```typescript
export function reactive(target: unknown) {
  // 参数类型检查
  if (!isObject(target)) {
    if (__DEV__) {
      console.warn(
        `reactive() 只能用于对象类型，收到的是: ${typeof target}`
      )
    }
    return target
  }
  
  // 检查是否已经是响应式对象
  if (target[ReactiveFlags.IS_REACTIVE]) {
    return target
  }
  
  // 检查是否是只读对象
  if (target[ReactiveFlags.IS_READONLY]) {
    return target
  }
  
  return createReactiveObject(target, mutableHandlers)
}
```

## 性能优化最佳实践

### 内存管理
```typescript
// 使用WeakMap避免内存泄漏
const targetMap = new WeakMap<any, KeyToDepMap>()
const reactiveMap = new WeakMap<Target, any>()

// effect清理机制
function cleanupEffect(effect: ReactiveEffect) {
  const { deps } = effect
  if (deps.length) {
    for (let i = 0; i < deps.length; i++) {
      deps[i].delete(effect)
    }
    deps.length = 0
  }
}
```

### 避免不必要的计算
```typescript
// 缓存计算结果
const hasChanged = (value: any, oldValue: any): boolean =>
  !Object.is(value, oldValue)

// 只在值真正改变时触发更新
set(target: object, key: string | symbol, value: unknown, receiver: object) {
  const oldValue = (target as any)[key]
  const result = Reflect.set(target, key, value, receiver)
  
  // 关键优化：只有值改变时才触发
  if (hasChanged(value, oldValue)) {
    trigger(target, TriggerOpTypes.SET, key, value, oldValue)
  }
  
  return result
}
```

### 懒加载和按需处理
```typescript
// 懒代理：只有访问时才创建嵌套对象的代理
get(target: object, key: string | symbol, receiver: object) {
  const res = Reflect.get(target, key, receiver)
  
  // 依赖收集
  track(target, TrackOpTypes.GET, key)
  
  // 懒代理：只有当访问到嵌套对象时才创建代理
  if (isObject(res)) {
    return reactive(res)
  }
  
  return res
}
```
## 文档和注释规范

### API文档模板
```typescript
/**
 * 创建一个响应式对象
 * 
 * @param target - 要转换为响应式的原始对象
 * @returns 响应式代理对象
 * 
 * @example
 * ```typescript
 * const state = reactive({ count: 0 })
 * effect(() => {
 *   console.log(state.count) // 当count变化时自动执行
 * })
 * state.count++ // 触发effect重新执行
 * ```
 * 
 * @remarks
 * - 只能用于对象类型，原始类型会直接返回
 * - 返回的代理对象与原对象不相等
 * - 支持深度响应式，嵌套对象也会被转换
 * 
 * @public
 */
export function reactive<T extends object>(target: T): UnwrapNestedRefs<T>
```

### 代码注释最佳实践
```typescript
export function track(target: object, type: TrackOpTypes, key: unknown) {
  // 如果没有活跃的effect，无需收集依赖
  if (activeEffect === undefined) {
    return
  }
  
  // 获取target对应的依赖映射表，如果不存在则创建
  let depsMap = targetMap.get(target)
  if (!depsMap) {
    targetMap.set(target, (depsMap = new Map()))
  }
  
  // 获取key对应的依赖集合，如果不存在则创建
  let dep = depsMap.get(key)
  if (!dep) {
    depsMap.set(key, (dep = new Set()))
  }
  
  // 建立双向关联：effect -> dep, dep -> effect
  if (!dep.has(activeEffect)) {
    dep.add(activeEffect)
    activeEffect.deps.push(dep)
    
    // 开发环境下记录依赖收集信息
    if (__DEV__ && activeEffect.options.onTrack) {
      activeEffect.options.onTrack({
        effect: activeEffect,
        target,
        type,
        key
      })
    }
  }
}
```

## 版本控制最佳实践

### Git提交规范
```bash
# 功能开发
git commit -m "feat(reactivity): 实现基础reactive函数

- 添加createReactiveObject核心逻辑
- 实现Proxy代理和缓存机制
- 添加类型定义和导出

Closes #123"

# Bug修复
git commit -m "fix(effect): 修复effect嵌套执行问题

- 使用effect栈管理嵌套关系
- 确保activeEffect正确恢复
- 添加相关测试用例

Fixes #456"

# 文档更新
git commit -m "docs: 更新响应式系统实现指南

- 添加依赖收集流程图
- 完善调试技巧说明
- 修正代码示例错误"
```

### 分支管理策略
```bash
# 主分支
main              # 稳定版本
develop           # 开发分支

# 功能分支
feature/reactive  # reactive功能实现
feature/effect    # effect系统实现
feature/computed  # computed实现

# 修复分支
hotfix/memory-leak    # 内存泄漏修复
bugfix/infinite-loop  # 无限循环修复
```

## 代码审查检查清单

### 功能性检查
- [ ] 功能是否按预期工作
- [ ] 边界情况是否处理
- [ ] 错误处理是否完善
- [ ] 性能是否满足要求

### 代码质量检查
- [ ] 命名是否清晰明确
- [ ] 函数是否职责单一
- [ ] 代码是否易于理解
- [ ] 注释是否恰当

### 类型安全检查
- [ ] 类型定义是否准确
- [ ] 是否避免使用any
- [ ] 泛型使用是否合理
- [ ] 类型推导是否正确

### 测试覆盖检查
- [ ] 单元测试是否充分
- [ ] 集成测试是否完整
- [ ] 边界情况是否测试
- [ ] 测试用例是否清晰

## 持续改进

### 代码重构指导
```typescript
// 重构前：功能耦合，难以维护
function reactiveHandler(target, key, value) {
  if (arguments.length === 2) {
    // get逻辑
    track(target, key)
    return target[key]
  } else {
    // set逻辑
    const oldValue = target[key]
    target[key] = value
    if (oldValue !== value) {
      trigger(target, key)
    }
  }
}

// 重构后：职责分离，清晰明确
const mutableHandlers = {
  get(target: object, key: string | symbol, receiver: object) {
    const result = Reflect.get(target, key, receiver)
    track(target, TrackOpTypes.GET, key)
    return isObject(result) ? reactive(result) : result
  },
  
  set(target: object, key: string | symbol, value: unknown, receiver: object) {
    const oldValue = (target as any)[key]
    const result = Reflect.set(target, key, value, receiver)
    
    if (hasChanged(value, oldValue)) {
      trigger(target, TriggerOpTypes.SET, key, value, oldValue)
    }
    
    return result
  }
}
```

### 性能监控和优化
```typescript
// 性能监控装饰器
function performanceMonitor(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
  const originalMethod = descriptor.value
  
  descriptor.value = function(...args: any[]) {
    const start = performance.now()
    const result = originalMethod.apply(this, args)
    const end = performance.now()
    
    if (end - start > 10) { // 超过10ms记录
      console.warn(`${propertyKey} 执行时间: ${end - start}ms`)
    }
    
    return result
  }
  
  return descriptor
}

// 使用示例
class ReactiveEffect {
  @performanceMonitor
  run() {
    // effect执行逻辑
  }
}
```